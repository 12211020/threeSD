// Generated by CoffeeScript 1.10.0
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.ThreeSD = (function() {
    var ADHERE_COMBINE, CONTROL_EVERYTHING, DEBUG, ELEMENT_TYPE, ENTER_EVERYTHING, LOG_INTERVAL, MAX_LOG, SCENE_TYPE, addAdhereBall, addObject, align, animate, canAdhere, canSelect, clearSelect, deselect, equals, exSelect, findParentUnderRoot, fixAdhere, fixCombinationPosition, getAxisAndAngle, getSelSize, getUserData, log, logCreate, logDelete, logLogs, logUpdate, logs, multiSelect, onDBClick, onMouseDown, onMouseMove, project, record, redo, removeObject, render, selSplice, select, self, setFocus, setParent, setRoot, sphere_end, sphere_start, undo, updateName, updateOBJ, updatePosition, updateRootBox, updateRotation, updateScale, updateSelBox, updateUserData;

    self = void 0;

    record = void 0;

    align = "";

    logs = [];

    logLogs = [];

    sphere_start = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10), new THREE.MeshBasicMaterial({
      color: 0xffff00
    }));

    sphere_end = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10), new THREE.MeshBasicMaterial({
      color: 0xffff00
    }));

    SCENE_TYPE = "整个场景";

    ELEMENT_TYPE = "__Element_Type";

    ENTER_EVERYTHING = true;

    ADHERE_COMBINE = true;

    CONTROL_EVERYTHING = false;

    DEBUG = false;

    LOG_INTERVAL = 100;

    MAX_LOG = 10000;

    function ThreeSD(divID) {
      this.ELEMENT_TYPE = ELEMENT_TYPE;
      this.container = document.getElementById(divID);
      this.camera = new THREE.PerspectiveCamera(45, this.container.offsetWidth / this.container.offsetHeight, 1, 31000);
      this.camera.position.set(0, 300, 600);
      this.camera.lookAt({
        x: 0,
        y: 0,
        z: 0
      });
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
      this.renderer.setClearColor(0x000000, 1.0);
      this.container.appendChild(this.renderer.domElement);
      this.ambientlight = new THREE.AmbientLight(0x404040, 0.5);
      this.light = new THREE.DirectionalLight(0xFFFFFF, 1.0);
      this.gridHelper = new THREE.GridHelper(1000, 50);
      this.gridHelper.setColors(0x0000ff, 0x808080);
      this.gridHelper.position.copy(new THREE.Vector3(0, 0, 0));
      if (DEBUG) {
        this.stats = new Stats();
        this.stats.domElement.style.position = 'absolute';
        this.stats.domElement.style.top = '50px';
        this.stats.domElement.style.right = '0px';
        this.stats.domElement.style.zIndex = 2333;
        this.container.appendChild(this.stats.domElement);
      }
      this.cameraControl = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      this.cameraControl.enableDamping = true;
      this.cameraControl.dampingFactor = 0.25;
      this.cameraControl.enableZoom = true;
      this.cameraControl.mouseButtons.PAN = void 0;
      this.mouse = new THREE.Vector2();
      this.mouseMode = "select";
      this.scene = new THREE.Scene();
      this.scene.name = SCENE_TYPE;
      this.scene.add(this.light);
      this.scene.add(this.ambientlight);
      this.scene.add(this.gridHelper);
      this.selected = [];
      this.onSelChange = void 0;
      this.onTransformChange = void 0;
      this.selectedBox = [];
      this.rootBox = new THREE.BoxHelper();
      this.rootBox.material.color.set(0xffffff);
      this.scene.add(this.rootBox);
      this.focus = null;
      this.root = this.scene;
      this.transformControl = new THREE.TransformControls(this.camera, this.renderer.domElement);
      this.scene.add(this.transformControl);
      this.container.addEventListener('mousedown', onMouseDown);
      this.container.addEventListener('mousemove', onMouseMove);
      this.container.addEventListener('dblclick', onDBClick);
      this.transformControl.addEventListener('objectChange', function() {
        logUpdate();
        fixAdhere();
        return self.onSelChange && self.onSelChange();
      });
      self = this;
      animate();
    }

    equals = function(A, B) {
      if (A.object !== B.object) {
        return false;
      }
      if (!A.position.equals(B.position)) {
        return false;
      }
      if (!A.rotation.equals(B.rotation)) {
        return false;
      }
      if (!A.scale.equals(B.scale)) {
        return false;
      }
      if (A.parent !== B.parent) {
        return false;
      }
      if (JSON.stringify(A.userData) !== JSON.stringify(B.userData)) {
        return false;
      }
      return true;
    };

    log = function(object, type) {
      var now;
      if (!object) {
        return;
      }
      logLogs.splice(0, logLogs.length);
      now = new Date();
      if (logs.length > 0 && Math.abs(logs[logs.length - 1].created_at - now) < LOG_INTERVAL) {
        logs[logs.length - 1].created_at = now;
        return;
      }
      logs.push({
        type: type,
        parent: object.parent,
        position: object.position.clone(),
        rotation: object.rotation.clone(),
        scale: object.scale.clone(),
        userData: JSON.parse(JSON.stringify(object.userData)),
        object: object,
        created_at: now
      });
      if (logs.length > MAX_LOG) {
        return logs.shift();
      }
    };

    logUpdate = function(object) {
      if (object == null) {
        object = self.focus;
      }
      return log(object, 'UPDATE');
    };

    logCreate = function(object) {
      if (object == null) {
        object = self.focus;
      }
      return log(object, 'CREATE');
    };

    logDelete = function(object) {
      if (object == null) {
        object = self.focus;
      }
      return log(object, 'DELETE');
    };

    undo = function() {
      var backup;
      if (logs.length === 0) {
        return;
      }
      backup = logs.pop();
      if (DEBUG) {
        console.log(logs.length);
      }
      switch (backup.type) {
        case 'UPDATE':
        case 'DELETE':
          if (backup.parent && backup.parent !== backup.object) {
            setParent(backup.object, backup.parent);
          }
          backup.object.position.copy(backup.position);
          backup.object.rotation.copy(backup.rotation);
          backup.object.scale.copy(backup.scale);
          backup.object.userData = backup.userData;
          multiSelect(backup.object);
          break;
        case 'CREATE':
          removeObject(backup.object);
          deselect(backup.object);
      }
      return logLogs.push(backup);
    };

    redo = function() {
      var backup;
      if (logLogs.length === 0) {
        return;
      }
      backup = logLogs.pop();
      if (DEBUG) {
        console.log(logLogs.length);
      }
      switch (backup.type) {
        case 'UPDATE':
        case 'CREATE':
          if (backup.parent && backup.parent !== backup.object) {
            setParent(backup.object, backup.parent);
          }
          backup.object.position.copy(backup.position);
          backup.object.rotation.copy(backup.rotation);
          backup.object.scale.copy(backup.scale);
          backup.object.userData = backup.userData;
          multiSelect(backup.object);
          break;
        case 'DELETE':
          removeObject(backup.object);
          deselect(backup.object);
      }
      return logs.push(backup);
    };

    animate = function() {
      requestAnimationFrame(animate);
      render();
    };

    render = function() {
      self.cameraControl.update();
      if (DEBUG) {
        self.stats.update();
      }
      self.light.position.copy(self.camera.position);
      self.transformControl.update();
      updateSelBox();
      updateRootBox();
      self.renderer.render(self.scene, self.camera);
    };

    updateOBJ = function(object, position, rotation, scale, name) {
      if (!object) {
        throw new Error("不知道要更新谁");
      }
      if (position) {
        object.position.copy(position);
      }
      if (rotation) {
        object.rotation.copy(rotation);
      }
      if (scale) {
        object.scale.copy(scale);
      }
      if (name) {
        object.name = name;
      }
      object.updateMatrix();
      object.updateMatrixWorld();
      return object;
    };

    updatePosition = function(position, object) {
      if (object == null) {
        object = self.focus;
      }
      return updateOBJ(object, position);
    };

    updateRotation = function(rotation, object) {
      if (object == null) {
        object = self.focus;
      }
      return updateOBJ(object, void 0, rotation);
    };

    updateScale = function(scale, object) {
      if (object == null) {
        object = self.focus;
      }
      return updateOBJ(object, void 0, void 0, scale);
    };

    updateName = function(name, object) {
      if (object == null) {
        object = self.focus;
      }
      return updateOBJ(object, void 0, void 0, void 0, name);
    };

    setRoot = function(object) {
      if (!object) {
        throw new Error("无法更新控制域");
      }
      fixCombinationPosition(self.root);
      return self.root = object;
    };

    setFocus = function(object) {
      if (!object) {
        console.log("没有焦点了哦");
      }
      return self.focus = object;
    };

    setParent = function(son, father) {
      var exFather, inverseMatrix;
      if (son == null) {
        son = self.focus;
      }
      if (father == null) {
        father = self.root;
      }
      if (!son) {
        throw new Error("找不到对象");
      }
      if (!father) {
        throw new Error("找不到对象");
      }
      if (son === father) {
        throw new Error("无效操作");
      }
      updateOBJ(son);
      updateOBJ(father);
      exFather = son.parent;
      if (exFather === father) {
        return;
      }
      if (exFather) {
        updateOBJ(exFather);
        son.applyMatrix(exFather.matrixWorld);
        inverseMatrix = (new THREE.Matrix4()).getInverse(father.matrixWorld);
        son.applyMatrix(inverseMatrix);
      }
      father.add(son);
      return son;
    };

    ThreeSD.prototype.suit = function() {
      var height, width;
      height = self.container.offsetHeight;
      width = self.container.offsetWidth;
      self.renderer.setSize(width, height);
      self.camera.aspect = width / height;
      self.camera.updateProjectionMatrix();
    };

    addAdhereBall = function(mouse) {
      var intersect, intersects, j, len, object, raycaster, ref;
      if (mouse == null) {
        mouse = self.mouse;
      }
      raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, self.camera);
      intersects = raycaster.intersectObjects(self.root.children, true);
      for (j = 0, len = intersects.length; j < len; j++) {
        intersect = intersects[j];
        object = intersect.object;
        while (object.parent && object.parent !== self.scene) {
          object = object.parent;
        }
        if (!object.parent) {
          continue;
        }
        if (object.visible === false) {
          continue;
        }
        if (object.userData.frozen === true) {
          return null;
        }
        if ((ref = object.userData.type) === ELEMENT_TYPE) {
          self.showOBJ(sphere_end);
          sphere_end.position.copy(intersect.point);
          return sphere_end;
        } else {
          continue;
        }
      }
      self.hideOBJ(sphere_end);
    };

    onMouseDown = function(event) {
      var mouse, ref, ref1;
      mouse = new THREE.Vector2();
      mouse.set((event.clientX - self.container.getBoundingClientRect().left) / self.container.clientWidth * 2 - 1, -(event.clientY - self.container.getBoundingClientRect().top) / self.container.clientHeight * 2 + 1);
      if ((ref = self.mouseMode) === 'select') {
        self.selectByMouse(mouse, event.ctrlKey, event.shiftKey);
      }
      if ((ref1 = self.mouseMode) === 'adhere') {
        self.adhere(mouse);
      }
    };

    onMouseMove = function(event) {
      var ref;
      self.mouse.set((event.clientX - self.container.getBoundingClientRect().left) / self.container.clientWidth * 2 - 1, -(event.clientY - self.container.getBoundingClientRect().top) / self.container.clientHeight * 2 + 1);
      if (((ref = self.mouseMode) === 'adhere') && record) {
        addAdhereBall();
      }
    };

    onDBClick = function(event) {
      var mouse, ref;
      mouse = new THREE.Vector2();
      mouse.set((event.clientX - self.container.getBoundingClientRect().left) / self.container.clientWidth * 2 - 1, -(event.clientY - self.container.getBoundingClientRect().top) / self.container.clientHeight * 2 + 1);
      if ((ref = self.mouseMode) === 'select') {
        self.enterByMouse(mouse);
      }
    };

    updateSelBox = function() {
      var base1, box, i, j, l, len, len1, ref, ref1, results, s;
      ref = self.selectedBox;
      for (j = 0, len = ref.length; j < len; j++) {
        box = ref[j];
        self.scene.remove(box);
      }
      ref1 = self.selected;
      results = [];
      for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
        s = ref1[i];
        if ((base1 = self.selectedBox)[i] == null) {
          base1[i] = new THREE.BoxHelper(s);
        }
        self.selectedBox[i].update(s);
        results.push(self.scene.add(self.selectedBox[i]));
      }
      return results;
    };

    updateRootBox = function() {
      if (self.root !== self.scene) {
        self.rootBox.update(self.root);
        return self.showOBJ(self.rootBox);
      } else {
        return self.hideOBJ(self.rootBox);
      }
    };

    selSplice = function(index, delCnt, object) {
      if (object) {
        self.selected.splice(index, delCnt, object);
      } else {
        self.selected.splice(index, delCnt);
      }
      self.focus = self.selected[0];
      if (self.focus && self.selected.length === 1) {
        self.transformControl.attach(self.focus);
        self.showOBJ(self.transformControl);
      } else {
        self.transformControl.detach();
        self.hideOBJ(self.transformControl);
      }
      self.onSelChange && self.onSelChange(self.selected);
    };

    select = function(object, multiple, exclusive) {
      if (multiple == null) {
        multiple = false;
      }
      if (exclusive == null) {
        exclusive = false;
      }
      if (multiple && exclusive) {
        deselect(object);
      } else if (multiple) {
        multiSelect(object);
      } else if (exclusive) {
        exSelect(object);
      } else {
        if (DEBUG) {
          console.log(object);
        }
        selSplice(0, self.selected.length, object);
      }
      return object;
    };

    multiSelect = function(object) {
      if (indexOf.call(self.selected, object) < 0) {
        return selSplice(0, 0, object);
      }
    };

    deselect = function(object) {
      var index;
      index = self.selected.indexOf(object);
      if (index >= 0) {
        return selSplice(index, 1);
      }
    };

    exSelect = function(object) {
      var index;
      index = self.selected.indexOf(object);
      if (index >= 0) {
        return selSplice(index, 1);
      } else {
        return selSplice(0, 0, object);
      }
    };

    clearSelect = function(object) {
      return selSplice(0, self.selected.length, object);
    };

    getSelSize = function() {
      return self.selected.length;
    };

    findParentUnderRoot = function(object) {
      while (object.parent && object.parent !== self.root) {
        object = object.parent;
      }
      return object;
    };

    canSelect = function(object) {
      var ref;
      if (!object instanceof THREE.Object3D) {
        return false;
      }
      if (object instanceof THREE.TransformControls) {
        return false;
      }
      if (object instanceof THREE.GridHelper) {
        return false;
      }
      if (object instanceof THREE.BoxHelper) {
        return false;
      }
      if (((ref = object.userData.type) === ELEMENT_TYPE) && object.visible && !object.userData.frozen) {
        return true;
      }
      if (CONTROL_EVERYTHING) {
        return true;
      }
      return false;
    };

    fixCombinationPosition = function(combination) {
      var center, child, j, l, len, len1, len2, m, parent, ref, ref1, ref2, weight;
      if (combination.userData.type !== ELEMENT_TYPE) {
        return;
      }
      if (!combination.parent) {
        return;
      }
      updateOBJ(combination);
      center = new THREE.Vector3(0, 0, 0);
      weight = 0;
      ref = combination.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        if (child.userData.type === ELEMENT_TYPE) {
          combination.localToWorld(child.position);
          if (child.userData.adhered) {
            continue;
          }
          center.x += child.position.x * child.userData.weight;
          center.y += child.position.y * child.userData.weight;
          center.z += child.position.z * child.userData.weight;
          weight += child.userData.weight;
        }
      }
      if (weight === 0) {
        ref1 = combination.children;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          child = ref1[l];
          if (child.userData.type === ELEMENT_TYPE) {
            combination.worldToLocal(child.position);
          }
        }
        return;
      }
      center.x /= weight;
      center.y /= weight;
      center.z /= weight;
      parent = combination.parent;
      updateOBJ(parent);
      parent.worldToLocal(center);
      updatePosition(center, combination);
      ref2 = combination.children;
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        child = ref2[m];
        combination.worldToLocal(child.position);
      }
      return fixCombinationPosition(parent);
    };

    addObject = function(object, name, position, root) {
      var base1, base2, base3, base4, base5, base6;
      if (name == null) {
        name = "Unnamed";
      }
      if (position == null) {
        position = new THREE.Vector3(0, 0, 0);
      }
      if (root == null) {
        root = self.root;
      }
      if (position) {
        object.position.copy(position);
      }
      object.name = name;
      if ((base1 = object.userData).type == null) {
        base1.type = ELEMENT_TYPE;
      }
      if ((base2 = object.userData).classifyType == null) {
        base2.classifyType = "不知名类型";
      }
      if ((base3 = object.userData).created_at == null) {
        base3.created_at = new Date();
      }
      if ((base4 = object.userData).frozen == null) {
        base4.frozen = false;
      }
      if ((base5 = object.userData).weight == null) {
        base5.weight = 1;
      }
      if ((base6 = object.userData).canAdhere == null) {
        base6.canAdhere = true;
      }
      updateUserData(object.userData, object);
      setParent(object, root);
      return object;
    };

    removeObject = function(object) {
      var parent;
      if (object === self.scene) {
        console.log("无效操作");
      }
      parent = object.parent;
      parent.remove(object);
      return parent;
    };

    getAxisAndAngle = function(normal1, normal2) {
      var angle, axis;
      normal1.normalize();
      normal2.normalize();
      axis = new THREE.Vector3().crossVectors(normal1, normal2);
      if (axis.length() === 0) {
        angle = Math.PI;
        if (normal1.equals(normal2)) {
          angle = 0;
        }
        axis = new THREE.Vector3(normal1.z, 0, -normal1.x);
        if (axis.length() === 0) {
          axis = new THREE.Vector3(1, 0, 0);
        }
      } else {
        angle = normal1.angleTo(normal2);
        axis = new THREE.Vector3().crossVectors(normal1, normal2);
      }
      axis.normalize();
      return {
        axis: axis,
        angle: angle
      };
    };

    project = function(point, panel_point, panel_normal) {
      var factor, k, t;
      t = panel_point.clone();
      t.sub(point);
      panel_normal.normalize();
      k = t.dot(panel_normal);
      factor = new THREE.Matrix3();
      factor.identity();
      factor.multiplyScalar(k);
      return panel_normal.clone().applyMatrix3(factor);
    };

    canAdhere = function(object) {
      while (object !== self.root) {
        if (object.userData.canAdhere === true) {
          return true;
        }
        object = object.parent;
      }
      return false;
    };


    /*
    使用face + object 计算目前吸附面在被吸附物体(father)坐标系下的方向 ->face,object
    记录在father坐标系下应当的向量方向->normal
    根据上面的计算进行方向调整
    
    记录在本体(son)坐标系下吸附的点位(destination) -> point(son)
    记录在father坐标系下吸附的点位(destination)   -> origin(father)
    根据这个来计算修正向量
     */

    fixAdhere = function(son) {
      var _tmp, father, normal, origin, point, ref, vector;
      if (son == null) {
        son = self.focus;
      }
      if ((son != null ? (ref = son.userData) != null ? ref.adhered : void 0 : void 0) === void 0) {
        return;
      }
      _tmp = son.matrixAutoUpdate;
      son.matrixAutoUpdate = false;
      updateOBJ(son);
      normal = new THREE.Vector3(son.userData.adhered.normal.x, son.userData.adhered.normal.y, son.userData.adhered.normal.z);
      father = son.parent;
      updateOBJ(father);
      point = new THREE.Vector3(son.userData.adhered.point.x, son.userData.adhered.point.y, son.userData.adhered.point.z);
      son.localToWorld(point);
      father.worldToLocal(point);
      origin = new THREE.Vector3(son.userData.adhered.origin.x, son.userData.adhered.origin.y, son.userData.adhered.origin.z);
      vector = project(point, origin, normal);
      son.position.add(vector);
      updateOBJ(son);
      son.matrixAutoUpdate = _tmp;
    };

    updateUserData = function(userData, object) {
      var key, results;
      if (object == null) {
        object = self.focus;
      }
      results = [];
      for (key in userData) {
        if (userData[key] === void 0) {
          results.push(delete object.userData[key]);
        } else {
          results.push(object.userData[key] = userData[key]);
        }
      }
      return results;
    };

    getUserData = function(object) {
      if (object == null) {
        object = self.focus;
      }
      return object.userData;
    };

    ThreeSD.prototype.updateOBJ = updateOBJ;

    ThreeSD.prototype.updatePosition = updatePosition;

    ThreeSD.prototype.updateRotation = updateRotation;

    ThreeSD.prototype.updateScale = updateScale;

    ThreeSD.prototype.updateName = updateName;

    ThreeSD.prototype.setRoot = setRoot;

    ThreeSD.prototype.setFocus = setFocus;

    ThreeSD.prototype.setParent = setParent;

    ThreeSD.prototype.updateUserData = updateUserData;

    ThreeSD.prototype.getUserData = getUserData;

    ThreeSD.prototype.undo = undo;

    ThreeSD.prototype.redo = redo;

    ThreeSD.prototype.addOBJMTL = function(object, name, position, root) {
      if (name == null) {
        name = "Unnamed";
      }
      if (position == null) {
        position = new THREE.Vector3(0, 0, 0);
      }
      if (root == null) {
        root = self.root;
      }
      addObject(object, name, position, root);
      logCreate(object);
      return clearSelect(object);
    };

    ThreeSD.prototype.findOBJById = function(id, object) {
      if (object == null) {
        object = self.root;
      }
      return object.getObjectById(id);
    };

    ThreeSD.prototype.enter = function(object) {
      var child, j, len, ref;
      setRoot(object);
      clearSelect();
      ref = object.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        multiSelect(child);
      }
      return object;
    };

    ThreeSD.prototype.enterByMouse = function(mouse, ctrl, shift) {
      var exist, intersect, intersects, j, len, object, raycaster;
      if (ctrl || shift) {
        return;
      }
      raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, self.camera);
      intersects = raycaster.intersectObjects(self.selected, true);
      if (intersects.length === 0) {
        setRoot(self.scene);
        clearSelect();
        return;
      }
      for (j = 0, len = intersects.length; j < len; j++) {
        intersect = intersects[j];
        object = findParentUnderRoot(intersect.object);
        if (!canSelect(object)) {
          continue;
        }
        exist = function() {
          var child, l, len1, ref, ref1;
          ref = object.children;
          for (l = 0, len1 = ref.length; l < len1; l++) {
            child = ref[l];
            if ((ref1 = child.userData.type) === ELEMENT_TYPE) {
              return true;
            }
          }
        };
        if (!exist()) {
          console.log("你点的物体里面没有可以修改的东西");
          break;
        }
        return self.enter(object);
      }
    };

    ThreeSD.prototype.select = select;

    ThreeSD.prototype.multiSelect = multiSelect;

    ThreeSD.prototype.deselect = deselect;

    ThreeSD.prototype.exSelect = exSelect;

    ThreeSD.prototype.clearSelect = clearSelect;

    ThreeSD.prototype.selectByMouse = function(mouse, ctrl, shift) {
      var intersect, intersects, j, len, object, raycaster;
      if (mouse == null) {
        mouse = self.mouse;
      }
      raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, self.camera);
      intersects = raycaster.intersectObjects(self.root.children, true);
      if (intersects.length === 0) {
        return null;
      }
      for (j = 0, len = intersects.length; j < len; j++) {
        intersect = intersects[j];
        object = findParentUnderRoot(intersect.object);
        if (!canSelect(object)) {
          continue;
        }
        return self.select(object, ctrl, shift);
      }
      return null;
    };

    ThreeSD.prototype.setTransformMode = function(mode) {
      if (mode !== "translate" && mode !== "rotate" && mode !== "scale") {
        throw new Error("没有这种操控模式");
      }
      self.transformControl.setMode(mode);
      if (mode !== 'scale') {
        self.transformControl.setSpace('world');
      }
    };

    ThreeSD.prototype.setTransformSpace = function(space) {
      if (self.transformControl.space === 'local') {
        if (space == null) {
          space = 'world';
        }
      } else {
        if (space == null) {
          space = 'local';
        }
      }
      if (self.transformControl.getMode() === 'scale') {
        space = 'local';
      }
      self.transformControl.setSpace(space);
    };

    ThreeSD.prototype.combine = function(array, root, _position) {
      var child, combination, j, l, len, len1, position, weight;
      if (array == null) {
        array = [];
      }
      if (root == null) {
        root = self.root;
      }
      if (array.length <= 1) {
        throw new Error("你不能把少于两个的元素组合在一起");
      }
      combination = new THREE.Object3D();
      addObject(combination);
      logCreate(combination);
      weight = 0;
      position = new THREE.Vector3(0, 0, 0);
      for (j = 0, len = array.length; j < len; j++) {
        child = array[j];
        position.x += child.position.x * child.userData.weight;
        position.y += child.position.y * child.userData.weight;
        position.z += child.position.z * child.userData.weight;
        weight += child.userData.weight;
      }
      updateUserData({
        weight: weight
      }, combination);
      if (_position) {
        updatePosition(_position, combination);
      } else {
        updatePosition(new THREE.Vector3(position.x / combination.userData.weight, position.y / combination.userData.weight, position.z / combination.userData.weight), combination);
      }
      updateOBJ(combination);
      for (l = 0, len1 = array.length; l < len1; l++) {
        child = array[l];
        logUpdate(child);
        setParent(child, combination);
      }
      return combination;
    };

    ThreeSD.prototype.combineSelected = function(name, position) {
      var combination;
      if (name == null) {
        name = "untitiled combination";
      }
      combination = self.combine(self.selected, self.root, position);
      updateName(name, combination);
      clearSelect(combination);
      return combination;
    };

    ThreeSD.prototype.separateFocus = function() {
      if (!self.focus) {
        throw new Error("找不到焦点");
      }
      return self.separate(self.focus, self.root);
    };

    ThreeSD.prototype.separate = function(combination, root) {
      var base, child, ref, ref1;
      if (root == null) {
        root = self.root;
      }
      if ((ref = combination.userData.type) !== ELEMENT_TYPE) {
        throw new Error("选中物体不能分离");
      }
      if (combination.parent !== root) {
        throw new Error("非法操作");
      }
      clearSelect();
      base = combination.children.length - 1;
      while (base >= 0) {
        child = combination.children[base];
        if ((ref1 = child.userData.type) === ELEMENT_TYPE) {
          logUpdate(child);
          setParent(child, root);
          multiSelect(child);
          if (child.userData.adhered) {
            logUpdate(child);
            updateUserData({
              adhered: void 0
            }, child);
            break;
          }
        }
        --base;
      }
      if (combination.children.length === 0) {
        self.remove(combination);
        return;
      }
      multiSelect(combination);
    };

    ThreeSD.prototype.deleteSel = function(root) {
      var j, len, ref, ref1, s;
      if (root == null) {
        root = self.root;
      }
      ref = self.selected;
      for (j = 0, len = ref.length; j < len; j++) {
        s = ref[j];
        self.remove(s);
      }
      while (((ref1 = root.userData.type) === ELEMENT_TYPE) && root.children.length === 0) {
        setRoot(self.remove(root));
      }
      selSplice(0, self.selected.length);
    };

    ThreeSD.prototype.showOBJ = function(object) {
      if (!object) {
        throw new Error("找不到对象");
      }
      object.visible = true;
      return object;
    };

    ThreeSD.prototype.hideOBJ = function(object) {
      if (!object) {
        throw new Error("找不到对象");
      }
      object.visible = false;
      self.deselect(object);
      return object;
    };

    ThreeSD.prototype.updateFocus = function(position, rotation, scale) {
      return self.updateOBJ(self.focus, position, rotation, scale);
    };

    ThreeSD.prototype.clear = function() {
      var child, j, len, r, tmp;
      clearSelect();
      tmp = (function() {
        var j, len, ref, ref1, results;
        ref = self.scene.children;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          if ((ref1 = child.userData.type) === ELEMENT_TYPE) {
            results.push(child);
          }
        }
        return results;
      })();
      for (j = 0, len = tmp.length; j < len; j++) {
        r = tmp[j];
        self.remove(r);
      }
    };

    ThreeSD.prototype.remove = function(object) {
      var parent, ref;
      logDelete(object);
      parent = removeObject(object);
      while (((ref = parent.userData.type) === ELEMENT_TYPE) && parent.children.length === 0) {
        parent = removeObject(parent);
      }
    };

    ThreeSD.prototype.adjust = function(intersect1, intersect2) {
      var _tmp, angle, axis, axisAndAngle, destination, normal1, normal2, object, position;
      normal1 = intersect1.face.normal.clone();
      intersect1.object.updateMatrixWorld();
      normal1.applyEuler(new THREE.Euler().setFromRotationMatrix(intersect1.object.matrixWorld));
      normal2 = intersect2.face.normal.clone();
      intersect2.object.updateMatrixWorld();
      normal2.applyEuler(new THREE.Euler().setFromRotationMatrix(intersect2.object.matrixWorld));
      axisAndAngle = getAxisAndAngle(normal1, normal2);
      object = findParentUnderRoot(intersect1.object);
      _tmp = object.matrixAutoUpdate;
      object.matrixAutoUpdate = false;
      axis = axisAndAngle.axis;
      angle = axisAndAngle.angle;
      if (!object.parent) {
        throw new Error("奇怪？");
      }
      position = intersect1.point;
      updateOBJ(object);
      object.worldToLocal(position);
      axis.applyEuler(new THREE.Euler().setFromRotationMatrix(new THREE.Matrix4().getInverse(object.matrixWorld)));
      object.rotateOnAxis(axis, angle + Math.PI);
      updateOBJ(object);
      object.localToWorld(position);
      destination = intersect2.point;
      self.root.updateMatrixWorld();
      self.root.worldToLocal(position);
      self.root.worldToLocal(destination);
      object.position.add(destination.clone().sub(position));
      self.root.localToWorld(destination);
      intersect1.normal = normal1;
      intersect2.normal = normal2;
      updateOBJ(object);
      object.matrixAutoUpdate = _tmp;
    };

    ThreeSD.prototype.adhere = function(mouse) {
      var adhered, father, intersect, intersects, j, len, normal, object, origin, point, raycaster, son, tmp, vector;
      if (mouse == null) {
        mouse = self.mouse;
      }
      raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, self.camera);
      intersects = raycaster.intersectObjects(self.root.children, true);
      if (intersects.length === 0) {
        return;
      }
      for (j = 0, len = intersects.length; j < len; j++) {
        intersect = intersects[j];
        object = findParentUnderRoot(intersect.object);
        if (!canSelect(object)) {
          continue;
        }
        if (!canAdhere(intersect.object)) {
          continue;
        }
        if (!record) {
          record = intersect;
          sphere_start.position.copy(intersect.point);
          self.showOBJ(sphere_start);
          self.scene.add(sphere_start);
          self.scene.add(sphere_end);
          self.hideOBJ(sphere_end);
        } else {
          if (findParentUnderRoot(record.object) === findParentUnderRoot(intersect.object)) {
            return;
          }
          father = findParentUnderRoot(intersect.object);
          son = findParentUnderRoot(record.object);
          logUpdate(father);
          logUpdate(son);
          self.adjust(record, intersect);
          father.updateMatrixWorld();
          son.updateMatrixWorld();
          self.root.updateMatrixWorld();
          if (ADHERE_COMBINE) {
            setParent(son, father);
            clearSelect(father);
          }
          if (align === 'x' || align === 'y' || align === 'z') {
            tmp = new THREE.Vector3(0, 0, 0);
            tmp[align] = son.position[align];
            updatePosition(tmp, son);
          }
          point = intersect.point.clone();
          origin = intersect.point.clone();
          son.worldToLocal(point);
          father.worldToLocal(origin);
          vector = intersect.normal.clone();
          vector.applyEuler(new THREE.Euler().setFromRotationMatrix(new THREE.Matrix4().getInverse(son.matrixWorld)));
          normal = intersect.normal.clone();
          normal.applyEuler(new THREE.Euler().setFromRotationMatrix(new THREE.Matrix4().getInverse(father.matrixWorld)));
          adhered = {
            point: {
              x: point.x,
              y: point.y,
              z: point.z
            },
            origin: {
              x: origin.x,
              y: origin.y,
              z: origin.z
            },
            vector: {
              x: vector.x,
              y: vector.y,
              z: vector.z
            },
            normal: {
              x: normal.x,
              y: normal.y,
              z: normal.z
            }
          };
          updateUserData({
            adhered: adhered
          }, son);
          self.setMouseMode('select');
        }
        break;
      }
    };

    ThreeSD.prototype.setMouseMode = function(mode) {
      if (mode !== 'select' && mode !== 'adhere' && mode !== 'selectBox') {
        throw new Error("没有这种Mode");
      }
      self.mouseMode = mode;
      console.log("已经切换到" + mode + "模式");
      if (mode === 'selectBox') {
        self.lockCamera();
      } else {
        self.unlockCamera();
      }
      if (mode !== 'select') {
        self.transformControl.detach();
        self.hideOBJ(self.transformControl);
      }
      if (mode !== 'adhere') {
        record = void 0;
        self.hideOBJ(sphere_start);
        self.hideOBJ(sphere_end);
      }
      return mode;
    };

    ThreeSD.prototype.lockCamera = function() {
      self.cameraControl.enabled = false;
    };

    ThreeSD.prototype.unlockCamera = function() {
      self.cameraControl.enabled = true;
    };

    ThreeSD.prototype.save = function() {
      var box, e, error, j, len, output, ref;
      output = "";
      self.scene.remove(self.transformControl);
      self.scene.remove(self.gridHelper);
      self.scene.remove(self.rootBox);
      ref = self.selectedBox;
      for (j = 0, len = ref.length; j < len; j++) {
        box = ref[j];
        self.scene.remove(box);
      }
      try {
        output = JSON.stringify(self.scene.toJSON());
        output = output.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
      } catch (error) {
        e = error;
        output = JSON.stringify(self.scene.toJSON());
      }
      self.scene.add(self.transformControl);
      self.scene.add(self.gridHelper);
      self.scene.add(self.rootBox);
      updateSelBox();
      updateRootBox();
      return output;
    };

    ThreeSD.prototype.saveFocus = function() {
      var e, error, output;
      if (!self.focus) {
        return;
      }
      output = void 0;
      try {
        output = JSON.stringify(self.focus.toJSON());
        output = output.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
      } catch (error) {
        e = error;
        console.log(e.message);
      }
      return output;
    };

    ThreeSD.prototype.load = function(save) {
      var box, j, len, loader, obj, ref;
      loader = new THREE.ObjectLoader();
      obj = loader.parse(JSON.parse(save));
      if (obj instanceof THREE.Scene) {
        clearSelect();
        self.scene.remove(self.transformControl);
        self.scene.remove(self.gridHelper);
        self.scene.remove(self.rootBox);
        ref = self.selectedBox;
        for (j = 0, len = ref.length; j < len; j++) {
          box = ref[j];
          self.scene.remove(box);
        }
        self.scene = obj;
        self.root = self.scene;
        self.scene.add(self.transformControl);
        self.scene.add(self.gridHelper);
        self.scene.add(self.rootBox);
        updateSelBox();
        updateRootBox();
      } else {
        self.addOBJMTL(obj);
      }
      return obj;
    };

    ThreeSD.prototype.setTarget = function(target) {
      if (target == null) {
        target = new THREE.Vector3(0, 0, 0);
      }
      self.cameraControl.target.copy(target);
      return self.cameraControl;
    };

    ThreeSD.prototype.setTargetOnFocus = function() {
      if (!self.focus) {
        throw new Error("找不到焦点");
      }
      self.root.updateMatrixWorld();
      self.cameraControl.target.copy(self.focus.position);
      self.root.localToWorld(self.cameraControl.target);
      return self.cameraControl;
    };

    ThreeSD.prototype.cloneFocus = function() {
      var res;
      if (!self.focus) {
        return;
      }
      res = self.focus.clone();
      setParent(res);
      return res;
    };

    ThreeSD.prototype.arrayClone = function(count, obj, axis) {
      var _normal, _origin, angle, copy, i, j, ref, ref1, up, vector;
      if (count == null) {
        count = 1;
      }
      if (obj == null) {
        obj = self.focus;
      }
      if (axis == null) {
        axis = new THREE.Vector3(0, 1, 0);
      }
      if ((obj != null ? (ref = obj.userData) != null ? ref.adhered : void 0 : void 0) === void 0) {
        return;
      }
      vector = obj.position.clone();
      angle = Math.PI * 2 / (count + 1);
      _normal = obj.userData.adhered.normal;
      _normal = new THREE.Vector3(_normal.x, _normal.y, _normal.z);
      _origin = obj.userData.adhered.origin;
      _origin = new THREE.Vector3(_origin.x, _origin.y, _origin.z);
      for (i = j = 1, ref1 = count; 1 <= ref1 ? j <= ref1 : j >= ref1; i = 1 <= ref1 ? ++j : --j) {
        vector.applyAxisAngle(axis, angle);
        _origin.applyAxisAngle(axis, angle);
        _normal.applyAxisAngle(axis, angle);
        copy = obj.clone();
        updatePosition(vector, copy);
        setParent(copy);
        up = axis.clone();
        up.applyEuler(new THREE.Euler().setFromRotationMatrix(new THREE.Matrix4().getInverse(copy.matrix)));
        copy.rotateOnAxis(up, i * angle);
        copy.userData.adhered.normal = {
          x: _normal.x,
          y: _normal.y,
          z: _normal.z
        };
        copy.userData.adhered.origin = {
          x: _origin.x,
          y: _origin.y,
          z: _origin.z
        };
        logCreate(copy);
      }
    };

    ThreeSD.prototype.setAlign = function(_align) {
      if (_align == null) {
        _align = '';
      }
      return align = _align;
    };

    ThreeSD.prototype.resetAlign = function() {
      return self.setAlign();
    };

    return ThreeSD;

  })();

}).call(this);

//# sourceMappingURL=ThreeSD.js.map
